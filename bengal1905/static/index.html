<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Bengal 1905: The Web of Alliances</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Lato:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>
<a href="../../index.html" class="back-link">&larr; All Readings</a>

<header>
  <h1>Bengal 1905: The Web of Alliances</h1>
  <div class="subtitle">A Network Game of Coalition Politics</div>
</header>

<main>
  <!-- VIGNETTE -->
  <div class="panel vignette-panel" id="vignettePanel">
    <div class="vignette-header">
      <h2 id="vignetteTitle">Loading...</h2>
    </div>
    <div id="vignetteText" class="vignette-text"></div>
    <button id="vignetteNext" class="cta-button" type="button">Continue</button>
  </div>

  <!-- GAME -->
  <div class="hidden" id="gameContainer">
    <div class="game-header">
      <div class="game-date" id="gameDate"></div>
      <div class="game-turn" id="gameTurn"></div>
    </div>

    <div class="network-container">
      <svg id="networkSvg" class="network-svg" viewBox="0 0 480 420" xmlns="http://www.w3.org/2000/svg">
        <g id="svgTies"></g>
        <g id="svgNodes"></g>
        <g id="svgIndicators"></g>
      </svg>
    </div>

    <div class="event-card" id="eventCard">
      <div class="event-title" id="eventTitle"></div>
      <div class="event-date-label" id="eventDateLabel"></div>
      <div class="event-narration" id="eventNarration"></div>
      <div class="historical-context" id="historicalContext">
        <div class="historical-context-label">Historical Context</div>
        <p id="historicalContextText"></p>
      </div>
      <div class="strain-summary" id="strainSummary">
        <div class="strain-summary-label">Ties Strained This Turn</div>
        <div id="strainItems"></div>
      </div>
    </div>

    <div class="tend-actions" id="tendActions">
      <div class="tend-label">Click a tie in the diagram — or choose below</div>
      <div class="tend-buttons" id="tendButtons"></div>
    </div>

    <div class="status-message" id="statusMessage"></div>
    <div class="score-panel hidden" id="scorePanel">
      <div class="score-total" id="scoreTotal"></div>
      <div class="score-label">Final Web Strength</div>
      <div class="score-rank" id="scoreRank"></div>
    </div>
    <div class="reflection-box hidden" id="reflectionBox"></div>
    <button class="secondary hidden" id="restartBtn" type="button">Start New Game</button>
  </div>
</main>

<script src="content.js"></script>
<script>
(function() {
  'use strict';

  const VIGNETTE = window.OPENING_VIGNETTE;
  const NODE_DEFS = window.NODE_DEFINITIONS || [];
  const TIE_DEFS = window.TIE_DEFINITIONS || [];
  const EVENTS = window.EVENT_CARDS || [];
  const DEFEATS = window.DEFEAT_NARRATIONS || {};
  const VICTORY = window.VICTORY_NARRATION || {};
  const GLOSSARY_ENTRIES = window.GLOSSARY || [];

  // Glossary
  const GLOSSARY_SORTED = [...GLOSSARY_ENTRIES].sort((a, b) => b.term.length - a.term.length);
  const GLOSSARY_PATTERN = GLOSSARY_SORTED.length
    ? new RegExp(`\\b(${GLOSSARY_SORTED.map(e => e.term.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|')})\\b`, 'gi')
    : null;

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c] || c));
  }
  function escapeAttr(s) { return escapeHtml(s).replace(/`/g, '&#96;'); }

  function applyGlossary(html) {
    if (!GLOSSARY_PATTERN) return html;
    return html.replace(GLOSSARY_PATTERN, match => {
      const entry = GLOSSARY_SORTED.find(e => e.term.toLowerCase() === match.toLowerCase().replace(/\s+/g, ' '));
      return entry ? `<span class="glossary-term" tabindex="0" data-description="${escapeAttr(entry.description)}">${match}</span>` : match;
    });
  }

  function formatText(text) {
    if (!text) return '';
    return applyGlossary(text.trim().split(/\n{2,}/).map(p => {
      let h = escapeHtml(p)
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(?!\*)([^*\n]+)\*/g, '<em>$1</em>')
        .replace(/\n/g, '<br/>');
      return `<p>${h}</p>`;
    }).join(''));
  }

  // Node positions (hexagonal)
  const CX = 240, CY = 200, RAD = 145;
  const nodePos = {};
  NODE_DEFS.forEach((def, i) => {
    const angle = (Math.PI / 2) + (2 * Math.PI * i) / NODE_DEFS.length;
    nodePos[def.id] = { x: CX + RAD * Math.cos(angle), y: CY - RAD * Math.sin(angle), ...def };
  });

  // Tie midpoints
  function tieMidpoint(tieId) {
    const tie = TIE_DEFS.find(t => t.id === tieId);
    if (!tie) return { x: CX, y: CY };
    const a = nodePos[tie.nodeA], b = nodePos[tie.nodeB];
    return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
  }

  // Adjacency: ties that share a node
  function adjacentTies(tieId) {
    const tie = TIE_DEFS.find(t => t.id === tieId);
    if (!tie) return [];
    return TIE_DEFS.filter(t => t.id !== tieId && (t.nodeA === tie.nodeA || t.nodeA === tie.nodeB || t.nodeB === tie.nodeA || t.nodeB === tie.nodeB)).map(t => t.id);
  }

  // Game constants
  const INITIAL = 60;
  const TEND_MIN = 15, TEND_MAX = 20;
  const DECAY_MIN = 1, DECAY_MAX = 2;
  const ADJ_BONUS = 1;
  const TOTAL_EVENTS = EVENTS.length;

  let state = null;
  let vigIdx = 0;
  let gameActive = false;
  let hoveredTie = null;

  function newState() {
    const ties = {};
    TIE_DEFS.forEach(t => { ties[t.id] = INITIAL; });
    return { ties, eventIndex: 0, gameOver: false, outcome: null };
  }

  // DOM
  const $ = id => document.getElementById(id);
  const vigPanel = $('vignettePanel'), vigTitle = $('vignetteTitle'), vigText = $('vignetteText'), vigNext = $('vignetteNext');
  const gameCont = $('gameContainer'), gameDateEl = $('gameDate'), gameTurnEl = $('gameTurn');
  const evTitle = $('eventTitle'), evDate = $('eventDateLabel'), evNarr = $('eventNarration');
  const histCtx = $('historicalContextText'), strainItems = $('strainItems');
  const tendBtns = $('tendButtons'), tendAct = $('tendActions');
  const statusMsg = $('statusMessage'), scorePanel = $('scorePanel'), scoreTotal = $('scoreTotal'), scoreRank = $('scoreRank');
  const reflBox = $('reflectionBox'), restartBtn = $('restartBtn');
  const svgTies = $('svgTies'), svgNodes = $('svgNodes'), svgInd = $('svgIndicators');

  // Vignette
  function showVig(idx) {
    if (!VIGNETTE || !VIGNETTE.pages) return;
    vigIdx = Math.min(Math.max(idx, 0), VIGNETTE.pages.length - 1);
    const p = VIGNETTE.pages[vigIdx];
    vigTitle.textContent = p.title || '';
    vigText.innerHTML = formatText(p.text || '');
    vigNext.textContent = p.button || (vigIdx === VIGNETTE.pages.length - 1 ? 'Begin Game' : 'Continue');
    scrollTo({ top: 0, behavior: 'smooth' });
  }

  vigNext.addEventListener('click', () => {
    if (VIGNETTE && vigIdx < VIGNETTE.pages.length - 1) showVig(vigIdx + 1);
    else beginGame();
  });

  // Begin game
  function beginGame() {
    vigPanel.classList.add('hidden');
    gameCont.classList.remove('hidden');
    state = newState();
    gameActive = true;
    buildSvg();
    showEvent();
  }

  // Build SVG
  function buildSvg() {
    svgTies.innerHTML = '';
    svgNodes.innerHTML = '';
    svgInd.innerHTML = '';

    // Draw ties
    TIE_DEFS.forEach(tie => {
      const a = nodePos[tie.nodeA], b = nodePos[tie.nodeB];
      const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };

      // Invisible hit area
      const hit = svgEl('line', {
        x1: a.x, y1: a.y, x2: b.x, y2: b.y,
        class: 'tie-hitarea', 'data-tie': tie.id
      });
      hit.addEventListener('click', () => onTieClick(tie.id));
      hit.addEventListener('mouseenter', () => onTieHover(tie.id, true));
      hit.addEventListener('mouseleave', () => onTieHover(tie.id, false));
      svgTies.appendChild(hit);

      // Visible line
      const line = svgEl('line', {
        x1: a.x, y1: a.y, x2: b.x, y2: b.y,
        class: 'tie-line', 'data-tie': tie.id
      });
      svgTies.appendChild(line);

      // Value label at midpoint
      const valLabel = svgEl('text', {
        x: mid.x, y: mid.y + 4,
        class: 'tie-value-label', 'data-tie': tie.id
      });
      valLabel.textContent = INITIAL;
      svgTies.appendChild(valLabel);

      // Hover label (tie name)
      const hoverLabel = svgEl('text', {
        x: mid.x, y: mid.y - 8,
        class: 'tie-hover-label', 'data-tie': tie.id
      });
      hoverLabel.textContent = tie.label;
      svgTies.appendChild(hoverLabel);
    });

    // Draw nodes (non-interactive)
    NODE_DEFS.forEach(def => {
      const pos = nodePos[def.id];
      const circle = svgEl('circle', {
        cx: pos.x, cy: pos.y, r: 22,
        fill: def.color, 'fill-opacity': '0.9',
        stroke: def.color, 'stroke-width': '2',
        class: 'network-node-circle'
      });
      svgNodes.appendChild(circle);

      const label = svgEl('text', {
        x: pos.x, y: pos.y + 4,
        class: 'network-node-label'
      });
      label.textContent = def.shortLabel;
      svgNodes.appendChild(label);
    });

    updateSvg();
  }

  function svgEl(tag, attrs) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
    return el;
  }

  function onTieHover(tieId, entering) {
    hoveredTie = entering ? tieId : null;
    svgTies.querySelectorAll(`.tie-hover-label`).forEach(el => {
      el.classList.toggle('visible', el.getAttribute('data-tie') === hoveredTie);
    });
  }

  function onTieClick(tieId) {
    if (!gameActive || !state || state.gameOver) return;
    tendTie(tieId);
  }

  // Update SVG visuals
  function updateSvg() {
    if (!state) return;

    TIE_DEFS.forEach(tie => {
      const val = state.ties[tie.id];
      const lines = svgTies.querySelectorAll(`.tie-line[data-tie="${tie.id}"]`);
      const valLabels = svgTies.querySelectorAll(`.tie-value-label[data-tie="${tie.id}"]`);

      const width = 1 + (val / 100) * 5;
      const opacity = 0.15 + (val / 100) * 0.7;

      lines.forEach(line => {
        line.setAttribute('stroke-width', width);
        line.setAttribute('stroke-opacity', opacity);
        if (val < 20) {
          line.classList.add('critical');
        } else {
          line.classList.remove('critical');
        }
      });

      valLabels.forEach(el => {
        el.textContent = val;
        el.classList.toggle('critical-text', val < 20);
      });
    });
  }

  // Show event
  function showEvent() {
    if (!state || state.eventIndex >= TOTAL_EVENTS) return;
    const ev = EVENTS[state.eventIndex];

    gameDateEl.textContent = ev.date;
    gameTurnEl.textContent = `Event ${state.eventIndex + 1} of ${TOTAL_EVENTS}`;
    evTitle.textContent = ev.title;
    evDate.textContent = ev.date;
    evNarr.innerHTML = formatText(ev.narration);
    histCtx.innerHTML = formatText(ev.historicalContext);

    // Strain summary
    let sHtml = '';
    ev.strains.forEach(s => {
      const tieDef = TIE_DEFS.find(t => t.id === s.tie);
      const name = tieDef ? tieDef.label : s.tie;
      sHtml += `<div class="strain-item"><span class="strain-tie-name">${escapeHtml(name)}</span> <span class="strain-amount">-${s.amount}</span>: ${escapeHtml(s.reason)}</div>`;
    });
    strainItems.innerHTML = sHtml;

    // Apply strains
    svgInd.innerHTML = '';
    ev.strains.forEach(s => {
      state.ties[s.tie] = Math.max(0, state.ties[s.tie] - s.amount);
      showIndicator(s.tie, `-${s.amount}`, 'strain-ind');
    });

    updateSvg();

    // Check defeat after strain
    const broken = checkDefeat();
    if (broken) { endGame('defeat', broken); return; }

    // Render tend options
    renderTendButtons();
    tendAct.classList.remove('hidden');

    scrollTo({ top: 0, behavior: 'smooth' });
  }

  function showIndicator(tieId, text, cls) {
    const mid = tieMidpoint(tieId);
    const offset = cls === 'decay-ind' ? 18 : cls === 'bonus-ind' ? -18 : cls === 'tend-ind' ? -22 : 0;
    const el = svgEl('text', {
      x: mid.x + (Math.random() * 16 - 8),
      y: mid.y + offset,
      class: `svg-indicator ${cls} show`
    });
    el.textContent = text;
    svgInd.appendChild(el);
  }

  // Tend buttons
  function renderTendButtons() {
    tendBtns.innerHTML = '';
    TIE_DEFS.forEach(tie => {
      const val = state.ties[tie.id];
      const nA = nodePos[tie.nodeA], nB = nodePos[tie.nodeB];
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'tend-btn';
      if (val < 20) btn.classList.add('crisis');
      btn.innerHTML = `
        <span class="tend-dots">
          <span class="tend-dot" style="background:${nA.color}"></span>
          <span class="tend-dot" style="background:${nB.color}"></span>
        </span>
        <span class="tend-info">
          <span class="tend-name">${escapeHtml(tie.label)}</span>
          <span class="tend-value">${escapeHtml(nA.shortLabel)} ↔ ${escapeHtml(nB.shortLabel)} · ${val}/100</span>
        </span>
      `;
      btn.addEventListener('click', () => tendTie(tie.id));
      // Highlight SVG on hover
      btn.addEventListener('mouseenter', () => onTieHover(tie.id, true));
      btn.addEventListener('mouseleave', () => onTieHover(tie.id, false));
      tendBtns.appendChild(btn);
    });
  }

  // Tend a tie
  function tendTie(tieId) {
    if (!gameActive || state.gameOver) return;
    const ev = EVENTS[state.eventIndex];

    // Disable buttons
    tendBtns.querySelectorAll('button').forEach(b => { b.disabled = true; });
    gameActive = false; // prevent double-click

    svgInd.innerHTML = '';

    // Tend: gain points
    const gain = TEND_MIN + Math.floor(Math.random() * (TEND_MAX - TEND_MIN + 1));
    state.ties[tieId] = Math.min(100, state.ties[tieId] + gain);
    showIndicator(tieId, `+${gain}`, 'tend-ind');

    // Glow animation on the tended line
    const tendedLine = svgTies.querySelector(`.tie-line[data-tie="${tieId}"]`);
    if (tendedLine) {
      tendedLine.classList.add('tie-tended');
      setTimeout(() => tendedLine.classList.remove('tie-tended'), 900);
    }

    // Adjacent bonus
    const adj = adjacentTies(tieId);
    const strainedSet = new Set(ev.strains.map(s => s.tie));

    adj.forEach(adjId => {
      if (strainedSet.has(adjId)) return; // don't bonus strained ties
      state.ties[adjId] = Math.min(100, state.ties[adjId] + ADJ_BONUS);
    });

    // Decay remaining ties
    const involved = new Set([tieId, ...adj, ...ev.strains.map(s => s.tie)]);
    TIE_DEFS.forEach(tie => {
      if (involved.has(tie.id)) return;
      const decay = DECAY_MIN + Math.floor(Math.random() * (DECAY_MAX - DECAY_MIN + 1));
      state.ties[tie.id] = Math.max(0, state.ties[tie.id] - decay);
      showIndicator(tie.id, `-${decay}`, 'decay-ind');
    });

    updateSvg();

    // Check defeat
    const broken = checkDefeat();
    if (broken) { endGame('defeat', broken); return; }

    // Advance
    state.eventIndex++;
    if (state.eventIndex >= TOTAL_EVENTS) { endGame('victory', null); return; }

    setTimeout(() => {
      gameActive = true;
      showEvent();
    }, 1200);
  }

  function checkDefeat() {
    for (const tie of TIE_DEFS) {
      if (state.ties[tie.id] <= 0) return tie.id;
    }
    return null;
  }

  function endGame(outcome, brokenTie) {
    state.gameOver = true;
    state.outcome = outcome;
    gameActive = false;
    tendAct.classList.add('hidden');

    const total = Object.values(state.ties).reduce((a, b) => a + b, 0);

    if (outcome === 'victory') {
      statusMsg.textContent = 'Victory — The web holds.';
      statusMsg.className = 'status-message status-victory';
      evTitle.textContent = VICTORY.title || 'Victory';
      evDate.textContent = 'December 1908';
      evNarr.innerHTML = formatText(VICTORY.narration || '');
      $('historicalContext').classList.add('hidden');
      $('strainSummary').classList.add('hidden');
      gameDateEl.textContent = 'December 1908';
      gameTurnEl.textContent = 'Game Complete';

      scorePanel.classList.remove('hidden');
      scoreTotal.textContent = total;
      scoreRank.textContent = getRank(total);

      if (VICTORY.reflection) {
        const items = VICTORY.reflection.map(p => `<li>${escapeHtml(p)}</li>`).join('');
        reflBox.innerHTML = `<div class="reflection-label">Reflection: The Price of Survival</div><p>Consider these questions in light of the course readings:</p><ul>${items}</ul>`;
        reflBox.classList.remove('hidden');
      }
    } else {
      const defeat = DEFEATS[brokenTie] || {};
      const tieDef = TIE_DEFS.find(t => t.id === brokenTie);
      statusMsg.textContent = `Defeat — ${defeat.title || (tieDef ? tieDef.label + ' snapped' : 'A tie has broken.')}`;
      statusMsg.className = 'status-message status-defeat';
      evTitle.textContent = defeat.title || 'The Web Breaks';
      evDate.textContent = EVENTS[state.eventIndex] ? EVENTS[state.eventIndex].date : '';
      evNarr.innerHTML = formatText(defeat.narration || '');
      $('historicalContext').classList.add('hidden');
      $('strainSummary').classList.add('hidden');
      gameTurnEl.textContent = 'Game Over';

      scorePanel.classList.remove('hidden');
      scoreTotal.textContent = total;
      scoreRank.textContent = 'Web Broken';

      if (defeat.reflection) {
        const items = defeat.reflection.map(p => `<li>${escapeHtml(p)}</li>`).join('');
        reflBox.innerHTML = `<div class="reflection-label">Reflection: ${escapeHtml(defeat.title || 'What Broke')}</div><p>Consider these questions in light of the course readings:</p><ul>${items}</ul>`;
        reflBox.classList.remove('hidden');
      }
    }

    restartBtn.classList.remove('hidden');
    scrollTo({ top: 0, behavior: 'smooth' });
  }

  function getRank(score) {
    if (score >= 750) return 'Master Web-Spinner';
    if (score >= 600) return 'Skilled Diplomat';
    if (score >= 450) return 'Embattled Negotiator';
    return 'Barely Survived';
  }

  restartBtn.addEventListener('click', () => {
    gameCont.classList.add('hidden');
    vigPanel.classList.remove('hidden');
    vigIdx = 0;
    showVig(0);
    statusMsg.textContent = '';
    statusMsg.className = 'status-message';
    scorePanel.classList.add('hidden');
    reflBox.innerHTML = '';
    reflBox.classList.add('hidden');
    restartBtn.classList.add('hidden');
    $('historicalContext').classList.remove('hidden');
    $('strainSummary').classList.remove('hidden');
    tendAct.classList.remove('hidden');
    state = null;
    gameActive = false;
  });

  // Init
  showVig(0);
})();
</script>
</body>
</html>
