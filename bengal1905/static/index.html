<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Bengal 1905: The Web of Alliances</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Lato:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>
<a href="../../index.html" class="back-link">&larr; All Readings</a>

<header>
  <h1>Bengal 1905: The Web of Alliances</h1>
  <div class="subtitle">A Network Game of Coalition Politics</div>
</header>

<main>
  <!-- ═══ VIGNETTE ═══ -->
  <div class="panel vignette-panel" id="vignettePanel">
    <div class="vignette-header">
      <h2 id="vignetteTitle">Loading...</h2>
    </div>
    <div id="vignetteText" class="vignette-text"></div>
    <button id="vignetteNext" class="cta-button" type="button">Continue</button>
  </div>

  <!-- ═══ GAME ═══ -->
  <div class="hidden" id="gameContainer">
    <!-- Header: date + turn -->
    <div class="game-header">
      <div class="game-date" id="gameDate">October 1905</div>
      <div class="game-turn" id="gameTurn">Event 1 of 18</div>
    </div>

    <!-- Network Diagram -->
    <div class="network-container">
      <svg id="networkSvg" class="network-svg" viewBox="0 0 460 400" xmlns="http://www.w3.org/2000/svg">
        <!-- Lines drawn by JS -->
        <g id="networkLines"></g>
        <!-- Nodes drawn by JS -->
        <g id="networkNodes"></g>
        <!-- Decay/strain indicators -->
        <g id="networkIndicators"></g>
      </svg>
    </div>

    <!-- Event Card -->
    <div class="event-card" id="eventCard">
      <div class="event-title" id="eventTitle"></div>
      <div class="event-date-label" id="eventDateLabel"></div>
      <div class="event-narration" id="eventNarration"></div>
      <div class="historical-context" id="historicalContext">
        <div class="historical-context-label">Historical Context</div>
        <p id="historicalContextText"></p>
      </div>
      <div class="strain-summary" id="strainSummary">
        <div class="strain-summary-label">Strained This Turn</div>
        <div id="strainItems"></div>
      </div>
    </div>

    <!-- Tend Buttons -->
    <div class="tend-actions" id="tendActions">
      <div class="tend-label">Choose one faction to tend</div>
      <div class="tend-buttons" id="tendButtons"></div>
    </div>

    <!-- Status / Outcome -->
    <div class="status-message" id="statusMessage"></div>

    <!-- Score -->
    <div class="score-panel hidden" id="scorePanel">
      <div class="score-total" id="scoreTotal"></div>
      <div class="score-label">Final Coalition Strength</div>
      <div class="score-rank" id="scoreRank"></div>
    </div>

    <!-- Reflection -->
    <div class="reflection-box hidden" id="reflectionBox"></div>

    <!-- Restart -->
    <button class="secondary hidden" id="restartBtn" type="button">Start New Game</button>
  </div>
</main>

<script src="content.js"></script>
<script>
(function() {
  'use strict';

  // ─── Content References ───
  const VIGNETTE = window.OPENING_VIGNETTE;
  const EVENTS = window.EVENT_CARDS || [];
  const DEFEATS = window.DEFEAT_NARRATIONS || {};
  const VICTORY = window.VICTORY_NARRATION || {};
  const GLOSSARY_ENTRIES = window.GLOSSARY || [];
  const NODE_DEFS = window.NODE_DEFINITIONS || [];

  // ─── Glossary Setup ───
  const GLOSSARY_SORTED = [...GLOSSARY_ENTRIES].sort((a, b) => b.term.length - a.term.length);
  const GLOSSARY_PATTERN = GLOSSARY_SORTED.length
    ? new RegExp(`\\b(${GLOSSARY_SORTED.map(e => e.term.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|')})\\b`, 'gi')
    : null;

  function escapeHtml(raw) {
    return (raw || '').replace(/[&<>"']/g, ch => {
      const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
      return map[ch] || ch;
    });
  }

  function escapeAttr(raw) {
    return escapeHtml(raw).replace(/`/g, '&#96;');
  }

  function applyGlossary(html) {
    if (!GLOSSARY_PATTERN) return html;
    return html.replace(GLOSSARY_PATTERN, match => {
      const normalized = match.toLowerCase().replace(/\s+/g, ' ');
      const entry = GLOSSARY_SORTED.find(e => e.term.toLowerCase() === normalized);
      if (!entry) return match;
      return `<span class="glossary-term" tabindex="0" data-description="${escapeAttr(entry.description)}">${match}</span>`;
    });
  }

  function formatText(text) {
    if (!text) return '';
    const trimmed = text.trim();
    const paragraphs = trimmed.split(/\n{2,}/);
    const html = paragraphs.map(p => {
      let escaped = escapeHtml(p)
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(?!\*)([^*\n]+)\*/g, '<em>$1</em>')
        .replace(/\n/g, '<br/>');
      return `<p>${escaped}</p>`;
    }).join('');
    return applyGlossary(html);
  }

  // ─── Node Positions (hexagonal layout) ───
  const CX = 230, CY = 195, R = 140;
  const NODE_POSITIONS = NODE_DEFS.map((def, i) => {
    const angle = (Math.PI / 2) + (2 * Math.PI * i) / NODE_DEFS.length;
    return {
      ...def,
      x: CX + R * Math.cos(angle),
      y: CY - R * Math.sin(angle)
    };
  });

  // ─── Game State ───
  const INITIAL_STRENGTH = 60;
  const DECAY_MIN = 3;
  const DECAY_MAX = 5;
  const TEND_MIN = 12;
  const TEND_MAX = 18;
  const TOTAL_EVENTS = EVENTS.length;

  let state = null;
  let currentVignetteIndex = 0;
  let gameActive = false;

  function newState() {
    const relationships = {};
    NODE_DEFS.forEach(def => { relationships[def.id] = INITIAL_STRENGTH; });
    return {
      relationships,
      eventIndex: 0,
      gameOver: false,
      outcome: null
    };
  }

  // ─── DOM References ───
  const vignettePanel = document.getElementById('vignettePanel');
  const vignetteTitle = document.getElementById('vignetteTitle');
  const vignetteText = document.getElementById('vignetteText');
  const vignetteNext = document.getElementById('vignetteNext');

  const gameContainer = document.getElementById('gameContainer');
  const gameDateEl = document.getElementById('gameDate');
  const gameTurnEl = document.getElementById('gameTurn');
  const eventTitle = document.getElementById('eventTitle');
  const eventDateLabel = document.getElementById('eventDateLabel');
  const eventNarration = document.getElementById('eventNarration');
  const historicalContextText = document.getElementById('historicalContextText');
  const strainItems = document.getElementById('strainItems');
  const tendButtons = document.getElementById('tendButtons');
  const statusMessage = document.getElementById('statusMessage');
  const scorePanel = document.getElementById('scorePanel');
  const scoreTotal = document.getElementById('scoreTotal');
  const scoreRank = document.getElementById('scoreRank');
  const reflectionBox = document.getElementById('reflectionBox');
  const restartBtn = document.getElementById('restartBtn');
  const tendActions = document.getElementById('tendActions');

  const svgLines = document.getElementById('networkLines');
  const svgNodes = document.getElementById('networkNodes');
  const svgIndicators = document.getElementById('networkIndicators');

  // ─── Vignette Flow ───
  function showVignettePage(index) {
    if (!VIGNETTE || !VIGNETTE.pages) return;
    currentVignetteIndex = Math.min(Math.max(index, 0), VIGNETTE.pages.length - 1);
    const page = VIGNETTE.pages[currentVignetteIndex];
    vignetteTitle.textContent = page.title || 'Briefing';
    vignetteText.innerHTML = formatText(page.text || '');
    const isLast = currentVignetteIndex === VIGNETTE.pages.length - 1;
    vignetteNext.textContent = page.button || (isLast ? 'Begin Game' : 'Continue');
    scrollToTop();
  }

  function advanceVignette() {
    if (VIGNETTE && currentVignetteIndex < VIGNETTE.pages.length - 1) {
      showVignettePage(currentVignetteIndex + 1);
    } else {
      beginGame();
    }
  }

  vignetteNext.addEventListener('click', advanceVignette);

  // ─── Game Start ───
  function beginGame() {
    vignettePanel.classList.add('hidden');
    gameContainer.classList.remove('hidden');
    state = newState();
    gameActive = true;
    renderNetwork();
    showEvent();
  }

  // ─── Network Rendering ───
  function renderNetwork() {
    svgLines.innerHTML = '';
    svgNodes.innerHTML = '';
    svgIndicators.innerHTML = '';

    // Draw all connecting lines (complete graph)
    for (let i = 0; i < NODE_POSITIONS.length; i++) {
      for (let j = i + 1; j < NODE_POSITIONS.length; j++) {
        const a = NODE_POSITIONS[i];
        const b = NODE_POSITIONS[j];
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', a.x);
        line.setAttribute('y1', a.y);
        line.setAttribute('x2', b.x);
        line.setAttribute('y2', b.y);
        line.setAttribute('class', 'network-line');
        line.setAttribute('data-nodes', `${a.id}-${b.id}`);
        svgLines.appendChild(line);
      }
    }

    // Draw nodes
    NODE_POSITIONS.forEach(node => {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'network-node-group');
      g.setAttribute('data-node', node.id);

      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', node.x);
      circle.setAttribute('cy', node.y);
      circle.setAttribute('r', 28);
      circle.setAttribute('fill', node.color);
      circle.setAttribute('fill-opacity', '0.85');
      circle.setAttribute('stroke', node.color);
      circle.setAttribute('stroke-width', '2');
      circle.setAttribute('class', 'network-node-circle');
      g.appendChild(circle);

      // Value text inside circle
      const valText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valText.setAttribute('x', node.x);
      valText.setAttribute('y', node.y + 5);
      valText.setAttribute('class', 'network-node-value');
      valText.textContent = INITIAL_STRENGTH;
      g.appendChild(valText);

      // Label below circle
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', node.x);
      label.setAttribute('y', node.y + 46);
      label.setAttribute('class', 'network-node-label');
      label.textContent = node.shortLabel;
      g.appendChild(label);

      svgNodes.appendChild(g);
    });

    updateNetworkVisuals();
  }

  function updateNetworkVisuals() {
    if (!state) return;

    // Update node circles and values
    NODE_POSITIONS.forEach(node => {
      const val = state.relationships[node.id];
      const g = svgNodes.querySelector(`[data-node="${node.id}"]`);
      if (!g) return;

      const circle = g.querySelector('.network-node-circle');
      const valText = g.querySelector('.network-node-value');

      // Scale radius based on strength
      const r = 18 + (val / 100) * 14;
      circle.setAttribute('r', r);

      // Opacity based on strength
      const opacity = 0.3 + (val / 100) * 0.6;
      circle.setAttribute('fill-opacity', opacity);

      valText.textContent = val;

      // Crisis styling
      g.classList.remove('node-crisis', 'node-imminent');
      if (val <= 0) {
        circle.setAttribute('fill-opacity', '0.15');
        circle.setAttribute('stroke', '#666');
      } else if (val < 15) {
        g.classList.add('node-imminent');
      } else if (val < 25) {
        g.classList.add('node-crisis');
      }
    });

    // Update lines
    svgLines.querySelectorAll('.network-line').forEach(line => {
      const [idA, idB] = line.getAttribute('data-nodes').split('-');
      const valA = state.relationships[idA] || 0;
      const valB = state.relationships[idB] || 0;
      const avg = (valA + valB) / 2;

      const width = 0.5 + (avg / 100) * 3.5;
      const opacity = 0.1 + (avg / 100) * 0.5;

      line.setAttribute('stroke-width', width);
      line.setAttribute('stroke-opacity', opacity);

      // Red pulsing for critical connections
      if (avg < 25) {
        line.classList.add('critical');
      } else {
        line.classList.remove('critical');
      }
    });
  }

  // ─── Show Event ───
  function showEvent() {
    if (!state || state.eventIndex >= TOTAL_EVENTS) return;

    const event = EVENTS[state.eventIndex];

    gameDateEl.textContent = event.date;
    gameTurnEl.textContent = `Event ${state.eventIndex + 1} of ${TOTAL_EVENTS}`;

    eventTitle.textContent = event.title;
    eventDateLabel.textContent = event.date;
    eventNarration.innerHTML = formatText(event.narration);
    historicalContextText.innerHTML = formatText(event.historicalContext);

    // Show strain summary
    let strainHtml = '';
    event.strains.forEach(s => {
      const nodeDef = NODE_DEFS.find(n => n.id === s.node);
      const name = nodeDef ? nodeDef.label : s.node;
      strainHtml += `<div class="strain-item"><span class="strain-node">${escapeHtml(name)}</span> <span class="strain-amount">-${s.amount}</span>: ${escapeHtml(s.reason)}</div>`;
    });
    strainItems.innerHTML = strainHtml;

    // Apply strains
    event.strains.forEach(s => {
      state.relationships[s.node] = Math.max(0, state.relationships[s.node] - s.amount);
    });

    // Show strain indicators on the network
    showStrainIndicators(event.strains);

    updateNetworkVisuals();

    // Check for defeat after strains
    const defeatNode = checkDefeat();
    if (defeatNode) {
      endGame('defeat', defeatNode);
      return;
    }

    // Render tend buttons
    renderTendButtons(event);
    tendActions.classList.remove('hidden');

    scrollToTop();
  }

  function showStrainIndicators(strains) {
    // Remove old indicators
    svgIndicators.innerHTML = '';

    strains.forEach(s => {
      const node = NODE_POSITIONS.find(n => n.id === s.node);
      if (!node) return;

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', node.x);
      text.setAttribute('y', node.y - 38);
      text.setAttribute('class', 'strain-indicator show');
      text.textContent = `-${s.amount}`;
      svgIndicators.appendChild(text);
    });
  }

  function showDecayIndicators(decayMap) {
    Object.entries(decayMap).forEach(([nodeId, amount]) => {
      const node = NODE_POSITIONS.find(n => n.id === nodeId);
      if (!node) return;

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', node.x + 20);
      text.setAttribute('y', node.y - 30);
      text.setAttribute('class', 'decay-indicator show');
      text.textContent = `-${amount}`;
      svgIndicators.appendChild(text);
    });
  }

  function showBonusIndicator(nodeId, amount) {
    const node = NODE_POSITIONS.find(n => n.id === nodeId);
    if (!node) return;

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', node.x - 20);
    text.setAttribute('y', node.y - 30);
    text.setAttribute('class', 'bonus-indicator show');
    text.textContent = `+${amount}`;
    svgIndicators.appendChild(text);
  }

  // ─── Tend Buttons ───
  function renderTendButtons(event) {
    tendButtons.innerHTML = '';

    NODE_DEFS.forEach(def => {
      const val = state.relationships[def.id];
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'tend-btn';
      if (val < 25) btn.classList.add('crisis');
      btn.style.borderLeftColor = def.color;

      const bonusInfo = event.tendBonus && event.tendBonus[def.id]
        ? ` (also +${event.tendBonus[def.id].amount} ${NODE_DEFS.find(n => n.id === event.tendBonus[def.id].target)?.shortLabel || ''})`
        : '';

      btn.innerHTML = `
        <span class="tend-dot" style="background:${def.color}"></span>
        <span class="tend-info">
          <span class="tend-name">${escapeHtml(def.label)}</span>
          <span class="tend-value">Current: ${val}/100${bonusInfo}</span>
        </span>
      `;

      btn.addEventListener('click', () => tendRelationship(def.id, event));
      tendButtons.appendChild(btn);
    });
  }

  // ─── Tend Action ───
  function tendRelationship(nodeId, event) {
    if (!gameActive || state.gameOver) return;

    // Disable buttons
    tendButtons.querySelectorAll('button').forEach(b => { b.disabled = true; });

    // Clear previous indicators
    svgIndicators.innerHTML = '';

    // Tend: gain points
    const tendAmount = TEND_MIN + Math.floor(Math.random() * (TEND_MAX - TEND_MIN + 1));
    state.relationships[nodeId] = Math.min(100, state.relationships[nodeId] + tendAmount);

    // Show tend glow
    const tendGroup = svgNodes.querySelector(`[data-node="${nodeId}"]`);
    if (tendGroup) {
      tendGroup.classList.add('node-tended');
      setTimeout(() => tendGroup.classList.remove('node-tended'), 900);
    }

    // Apply bonus
    if (event.tendBonus && event.tendBonus[nodeId]) {
      const bonus = event.tendBonus[nodeId];
      state.relationships[bonus.target] = Math.min(100, Math.max(0, state.relationships[bonus.target] + bonus.amount));
      showBonusIndicator(bonus.target, bonus.amount);
    }

    // Decay untended, unstrained nodes
    const strainedNodes = new Set(event.strains.map(s => s.node));
    const decayMap = {};

    NODE_DEFS.forEach(def => {
      if (def.id === nodeId) return; // tended
      if (strainedNodes.has(def.id)) return; // already strained
      const decay = DECAY_MIN + Math.floor(Math.random() * (DECAY_MAX - DECAY_MIN + 1));
      state.relationships[def.id] = Math.max(0, state.relationships[def.id] - decay);
      decayMap[def.id] = decay;
    });

    showDecayIndicators(decayMap);
    updateNetworkVisuals();

    // Check defeat
    const defeatNode = checkDefeat();
    if (defeatNode) {
      endGame('defeat', defeatNode);
      return;
    }

    // Advance
    state.eventIndex++;

    if (state.eventIndex >= TOTAL_EVENTS) {
      endGame('victory', null);
      return;
    }

    // Next event after a brief pause
    setTimeout(() => {
      showEvent();
    }, 1200);
  }

  // ─── Win/Loss Detection ───
  function checkDefeat() {
    for (const def of NODE_DEFS) {
      if (state.relationships[def.id] <= 0) {
        return def.id;
      }
    }
    return null;
  }

  function endGame(outcome, brokenNode) {
    state.gameOver = true;
    state.outcome = outcome;
    gameActive = false;

    tendActions.classList.add('hidden');

    const totalScore = Object.values(state.relationships).reduce((a, b) => a + b, 0);

    if (outcome === 'victory') {
      statusMessage.textContent = 'Victory — You held the coalition together.';
      statusMessage.className = 'status-message status-victory';

      // Show victory narration in event card
      eventTitle.textContent = VICTORY.title || 'Victory';
      eventDateLabel.textContent = 'December 1908';
      eventNarration.innerHTML = formatText(VICTORY.narration || '');
      document.getElementById('historicalContext').classList.add('hidden');
      document.getElementById('strainSummary').classList.add('hidden');

      gameDateEl.textContent = 'December 1908';
      gameTurnEl.textContent = 'Game Complete';

      // Show score
      scorePanel.classList.remove('hidden');
      scoreTotal.textContent = totalScore;
      scoreRank.textContent = getRank(totalScore);

      // Show reflection
      if (VICTORY.reflection && VICTORY.reflection.length) {
        const items = VICTORY.reflection.map(p => `<li>${escapeHtml(p)}</li>`).join('');
        reflectionBox.innerHTML = `
          <div class="reflection-label">Reflection: The Price of Survival</div>
          <p>Before you restart, consider these questions in light of the course readings:</p>
          <ul>${items}</ul>
        `;
        reflectionBox.classList.remove('hidden');
      }
    } else {
      const defeat = DEFEATS[brokenNode] || {};
      statusMessage.textContent = `Defeat — ${defeat.title || 'A faction has broken with you.'}`;
      statusMessage.className = 'status-message status-defeat';

      // Show defeat narration
      eventTitle.textContent = defeat.title || 'Coalition Collapse';
      eventDateLabel.textContent = EVENTS[state.eventIndex] ? EVENTS[state.eventIndex].date : '';
      eventNarration.innerHTML = formatText(defeat.narration || '');
      document.getElementById('historicalContext').classList.add('hidden');
      document.getElementById('strainSummary').classList.add('hidden');

      gameTurnEl.textContent = 'Game Over';

      // Show score
      scorePanel.classList.remove('hidden');
      scoreTotal.textContent = totalScore;
      scoreRank.textContent = 'Coalition Broken';

      // Show reflection
      if (defeat.reflection && defeat.reflection.length) {
        const nodeDef = NODE_DEFS.find(n => n.id === brokenNode);
        const items = defeat.reflection.map(p => `<li>${escapeHtml(p)}</li>`).join('');
        reflectionBox.innerHTML = `
          <div class="reflection-label">Reflection: ${escapeHtml(defeat.title || 'What Went Wrong')}</div>
          <p>Consider these questions in light of the course readings:</p>
          <ul>${items}</ul>
        `;
        reflectionBox.classList.remove('hidden');
      }
    }

    restartBtn.classList.remove('hidden');
    scrollToTop();
  }

  function getRank(score) {
    if (score >= 300) return 'Master Coalition Builder';
    if (score >= 250) return 'Skilled Diplomat';
    if (score >= 200) return 'Embattled Leader';
    return 'Barely Survived';
  }

  // ─── Restart ───
  restartBtn.addEventListener('click', () => {
    gameContainer.classList.add('hidden');
    vignettePanel.classList.remove('hidden');
    currentVignetteIndex = 0;
    showVignettePage(0);

    // Reset UI
    statusMessage.textContent = '';
    statusMessage.className = 'status-message';
    scorePanel.classList.add('hidden');
    reflectionBox.innerHTML = '';
    reflectionBox.classList.add('hidden');
    restartBtn.classList.add('hidden');
    document.getElementById('historicalContext').classList.remove('hidden');
    document.getElementById('strainSummary').classList.remove('hidden');
    tendActions.classList.remove('hidden');

    state = null;
    gameActive = false;
  });

  // ─── Utility ───
  function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  // ─── Init ───
  showVignettePage(0);

})();
</script>
</body>
</html>
