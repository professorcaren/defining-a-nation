<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Bengal 1905: The Web of Alliances</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Lato:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css"/>
</head>
<body>
<a href="../../index.html" class="back-link">&larr; All Readings</a>

<header>
  <h1>Bengal 1905: The Web of Alliances</h1>
  <div class="subtitle">A Network Game of Coalition Politics</div>
</header>

<main>
  <!-- VIGNETTE -->
  <div class="vignette-panel" id="vignettePanel">
    <div class="vignette-header">
      <h2 id="vignetteTitle">Loading...</h2>
    </div>
    <div id="vignetteText" class="vignette-text"></div>
    <button id="vignetteNext" class="cta-button" type="button">Continue</button>
  </div>

  <!-- GAME -->
  <div class="hidden" id="gameContainer">
    <!-- Progress bar -->
    <div class="progress-bar" id="progressBar">
      <span class="game-date" id="gameDate"></span>
      <div class="progress-dots" id="progressDots"></div>
    </div>

    <!-- Network diagram -->
    <div class="network-container">
      <svg id="networkSvg" class="network-svg" viewBox="0 0 480 420" xmlns="http://www.w3.org/2000/svg">
        <g id="svgTies"></g>
        <g id="svgNodes"></g>
        <g id="svgIndicators"></g>
      </svg>
      <div class="telegraph-overlay hidden" id="telegraphOverlay">
        <span id="telegraphText"></span>
      </div>
      <div class="action-overlay" id="actionOverlay"></div>
    </div>

    <!-- Event text (compact) -->
    <div class="event-compact" id="eventCompact">
      <div class="event-title" id="eventTitle"></div>
      <div class="event-narration" id="eventNarration"></div>
      <button class="learn-more-toggle hidden" id="learnMoreToggle" type="button">Learn more &#9656;</button>
      <div class="learn-more-content" id="learnMoreContent"></div>
    </div>

    <!-- Action cards -->
    <div class="action-area" id="actionArea">
      <div class="action-cards" id="actionCards"></div>
    </div>

    <!-- Tutorial hint -->
    <div class="tutorial-hint hidden" id="tutorialHint"></div>

    <!-- End game panels -->
    <div class="status-message" id="statusMessage"></div>
    <div class="score-panel hidden" id="scorePanel">
      <div class="score-total" id="scoreTotal"></div>
      <div class="score-label">Final Web Strength</div>
      <div class="score-rank" id="scoreRank"></div>
    </div>
    <div class="reflection-box hidden" id="reflectionBox"></div>
    <button class="secondary hidden" id="restartBtn" type="button">Play Again</button>
  </div>
</main>

<script src="content.js"></script>
<script>
(function() {
  'use strict';

  /* ═══════════════════════════════════════════════════
     DATA
     ═══════════════════════════════════════════════════ */

  const VIGNETTE = window.OPENING_VIGNETTE;
  const NODE_DEFS = window.NODE_DEFINITIONS || [];
  const TIE_DEFS = window.TIE_DEFINITIONS || [];
  const EVENTS = window.EVENT_CARDS || [];
  const TUTORIAL = window.TUTORIAL_EVENT;
  const DEFEATS = window.DEFEAT_NARRATIONS || {};
  const VICTORY = window.VICTORY_NARRATION || {};
  const GLOSSARY_ENTRIES = window.GLOSSARY || [];

  /* ═══════════════════════════════════════════════════
     GLOSSARY
     ═══════════════════════════════════════════════════ */

  const GLOSSARY_SORTED = [...GLOSSARY_ENTRIES].sort((a, b) => b.term.length - a.term.length);
  const GLOSSARY_PATTERN = GLOSSARY_SORTED.length
    ? new RegExp(`\\b(${GLOSSARY_SORTED.map(e => e.term.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|')})\\b`, 'gi')
    : null;

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c] || c));
  }
  function escapeAttr(s) { return escapeHtml(s).replace(/`/g, '&#96;'); }

  function applyGlossary(html) {
    if (!GLOSSARY_PATTERN) return html;
    return html.replace(GLOSSARY_PATTERN, match => {
      const entry = GLOSSARY_SORTED.find(e => e.term.toLowerCase() === match.toLowerCase().replace(/\s+/g, ' '));
      return entry ? `<span class="glossary-term" tabindex="0" data-description="${escapeAttr(entry.description)}">${match}</span>` : match;
    });
  }

  function formatText(text) {
    if (!text) return '';
    return applyGlossary(text.trim().split(/\n{2,}/).map(p => {
      let h = escapeHtml(p)
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(?!\*)([^*\n]+)\*/g, '<em>$1</em>')
        .replace(/\n/g, '<br/>');
      return `<p>${h}</p>`;
    }).join(''));
  }

  /* ═══════════════════════════════════════════════════
     GEOMETRY
     ═══════════════════════════════════════════════════ */

  const CX = 240, CY = 200, RAD = 145;
  const nodePos = {};
  NODE_DEFS.forEach((def, i) => {
    const angle = (Math.PI / 2) + (2 * Math.PI * i) / NODE_DEFS.length;
    nodePos[def.id] = { x: CX + RAD * Math.cos(angle), y: CY - RAD * Math.sin(angle), ...def };
  });

  function tieMidpoint(tieId) {
    const tie = TIE_DEFS.find(t => t.id === tieId);
    if (!tie) return { x: CX, y: CY };
    const a = nodePos[tie.nodeA], b = nodePos[tie.nodeB];
    return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
  }

  /* ═══════════════════════════════════════════════════
     GAME CONSTANTS
     ═══════════════════════════════════════════════════ */

  const INITIAL = 60;
  const DECAY_MIN = 1, DECAY_MAX = 2;
  const TOTAL_EVENTS = EVENTS.length;

  let state = null;
  let vigIdx = 0;
  let gameActive = false;

  function newState() {
    const ties = {};
    TIE_DEFS.forEach(t => { ties[t.id] = INITIAL; });
    return { ties, eventIndex: 0, gameOver: false, outcome: null };
  }

  /* ═══════════════════════════════════════════════════
     DOM REFS
     ═══════════════════════════════════════════════════ */

  const $ = id => document.getElementById(id);
  const vigPanel = $('vignettePanel'), vigTitle = $('vignetteTitle');
  const vigText = $('vignetteText'), vigNext = $('vignetteNext');
  const gameCont = $('gameContainer'), gameDateEl = $('gameDate');
  const evTitle = $('eventTitle'), evNarr = $('eventNarration');
  const learnMoreToggle = $('learnMoreToggle'), learnMoreContent = $('learnMoreContent');
  const actionCards = $('actionCards'), actionArea = $('actionArea');
  const telegraphOverlay = $('telegraphOverlay'), telegraphText = $('telegraphText');
  const tutorialHint = $('tutorialHint');
  const statusMsg = $('statusMessage'), scorePanel = $('scorePanel');
  const scoreTotal = $('scoreTotal'), scoreRank = $('scoreRank');
  const reflBox = $('reflectionBox'), restartBtn = $('restartBtn');
  const svgTies = $('svgTies'), svgNodes = $('svgNodes'), svgInd = $('svgIndicators');
  const actionOverlay = $('actionOverlay');
  const networkSvg = $('networkSvg');

  /* ═══════════════════════════════════════════════════
     VIGNETTE
     ═══════════════════════════════════════════════════ */

  function showVig(idx) {
    if (!VIGNETTE || !VIGNETTE.pages) return;
    vigIdx = Math.min(Math.max(idx, 0), VIGNETTE.pages.length - 1);
    const p = VIGNETTE.pages[vigIdx];
    vigTitle.textContent = p.title || '';
    vigText.innerHTML = formatText(p.text || '');
    vigNext.textContent = p.button || 'Continue';
  }

  vigNext.addEventListener('click', () => {
    if (VIGNETTE && vigIdx < VIGNETTE.pages.length - 1) {
      showVig(vigIdx + 1);
    } else {
      startGame();
    }
  });

  function startGame() {
    vigPanel.classList.add('hidden');
    gameCont.classList.remove('hidden');
    state = newState();
    buildSvg();
    buildProgressDots();
    gameActive = true;
    showEvent();
  }

  function showHint(text) {
    tutorialHint.textContent = text;
    tutorialHint.classList.remove('hidden');
  }

  function hideHint() {
    tutorialHint.classList.add('hidden');
  }

  /* ═══════════════════════════════════════════════════
     SVG — BUILD & UPDATE
     ═══════════════════════════════════════════════════ */

  function svgEl(tag, attrs) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
    Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
    return el;
  }

  function buildSvg() {
    svgTies.innerHTML = '';
    svgNodes.innerHTML = '';
    svgInd.innerHTML = '';

    // Draw ties
    TIE_DEFS.forEach(tie => {
      const a = nodePos[tie.nodeA], b = nodePos[tie.nodeB];
      const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };

      // Visible line
      const line = svgEl('line', {
        x1: a.x, y1: a.y, x2: b.x, y2: b.y,
        class: 'tie-line', 'data-tie': tie.id
      });
      svgTies.appendChild(line);

      // Value label at midpoint
      const valLabel = svgEl('text', {
        x: mid.x, y: mid.y + 4,
        class: 'tie-value-label', 'data-tie': tie.id
      });
      valLabel.textContent = INITIAL;
      svgTies.appendChild(valLabel);

      // Hover label (tie name)
      const hoverLabel = svgEl('text', {
        x: mid.x, y: mid.y - 8,
        class: 'tie-hover-label', 'data-tie': tie.id
      });
      hoverLabel.textContent = tie.label;
      svgTies.appendChild(hoverLabel);
    });

    // Draw nodes
    NODE_DEFS.forEach(def => {
      const pos = nodePos[def.id];

      // Ambient glow
      const glow = svgEl('circle', {
        cx: pos.x, cy: pos.y, r: 28,
        fill: def.color, 'fill-opacity': '0.08',
        class: 'node-glow', 'data-node': def.id
      });
      svgNodes.appendChild(glow);

      const circle = svgEl('circle', {
        cx: pos.x, cy: pos.y, r: 18,
        fill: def.color, 'fill-opacity': '0.9',
        stroke: def.color, 'stroke-width': '1.5',
        class: 'network-node-circle', 'data-node': def.id
      });
      svgNodes.appendChild(circle);

      const label = svgEl('text', {
        x: pos.x, y: pos.y + 3,
        class: 'network-node-label'
      });
      label.textContent = def.shortLabel;
      svgNodes.appendChild(label);
    });

    updateSvg();
  }

  function updateSvg() {
    if (!state) return;

    TIE_DEFS.forEach(tie => {
      const val = state.ties[tie.id];
      const lines = svgTies.querySelectorAll(`.tie-line[data-tie="${tie.id}"]`);
      const valLabels = svgTies.querySelectorAll(`.tie-value-label[data-tie="${tie.id}"]`);

      const width = 1 + (val / 100) * 4;
      const opacity = 0.12 + (val / 100) * 0.7;

      lines.forEach(line => {
        line.setAttribute('stroke-width', width);
        line.setAttribute('stroke-opacity', opacity);

        // Remove all state classes first
        line.classList.remove('critical', 'healthy');

        if (val <= 0) {
          line.setAttribute('stroke-opacity', '0');
        } else if (val < 20) {
          line.classList.add('critical');
        } else if (val > 70) {
          line.classList.add('healthy');
        }
      });

      valLabels.forEach(el => {
        el.textContent = val;
        el.classList.toggle('critical-text', val < 20);
      });
    });
  }

  /* ═══════════════════════════════════════════════════
     ANIMATIONS
     ═══════════════════════════════════════════════════ */

  function showIndicator(tieId, text, cls) {
    const mid = tieMidpoint(tieId);
    const xOff = (Math.random() * 14 - 7);
    const yOff = cls === 'tend-ind' ? -16 : cls === 'decay-ind' ? 14 : cls === 'side-cost-ind' ? -20 : 0;
    const el = svgEl('text', {
      x: mid.x + xOff,
      y: mid.y + yOff,
      class: `svg-indicator ${cls} show`
    });
    el.textContent = text;
    svgInd.appendChild(el);
  }

  function animateStrain(tieId, amount) {
    // Flash the line red
    const line = svgTies.querySelector(`.tie-line[data-tie="${tieId}"]`);
    if (line) {
      line.classList.add('strain-flash');
      setTimeout(() => line.classList.remove('strain-flash'), 500);
    }

    // Show floating indicator
    showIndicator(tieId, `-${amount}`, 'strain-ind');

    // Show hover label briefly
    const hoverLabel = svgTies.querySelector(`.tie-hover-label[data-tie="${tieId}"]`);
    if (hoverLabel) {
      hoverLabel.classList.add('visible');
      setTimeout(() => hoverLabel.classList.remove('visible'), 1500);
    }
  }

  function animateTend(tieId, amount) {
    const line = svgTies.querySelector(`.tie-line[data-tie="${tieId}"]`);
    if (line) {
      line.classList.add('tie-tended');
      setTimeout(() => line.classList.remove('tie-tended'), 900);
    }

    // Node bounce
    const tie = TIE_DEFS.find(t => t.id === tieId);
    if (tie) {
      [tie.nodeA, tie.nodeB].forEach(nodeId => {
        const circle = svgNodes.querySelector(`.network-node-circle[data-node="${nodeId}"]`);
        if (circle) {
          circle.classList.add('node-react');
          setTimeout(() => circle.classList.remove('node-react'), 400);
        }
      });
    }

    showIndicator(tieId, `+${amount}`, 'tend-ind');

    // Show hover label
    const hoverLabel = svgTies.querySelector(`.tie-hover-label[data-tie="${tieId}"]`);
    if (hoverLabel) {
      hoverLabel.classList.add('visible');
      setTimeout(() => hoverLabel.classList.remove('visible'), 1200);
    }
  }

  function animateSideCost(tieId, amount) {
    if (amount < 0) {
      animateStrain(tieId, Math.abs(amount));
    } else {
      showIndicator(tieId, `+${amount}`, 'bonus-ind');
    }
  }

  /* ═══════════════════════════════════════════════════
     TELEGRAPH
     ═══════════════════════════════════════════════════ */

  function showTelegraph(text, callback) {
    if (!text) { callback(); return; }
    telegraphText.textContent = text;
    telegraphOverlay.classList.remove('hidden', 'fading');

    setTimeout(() => {
      telegraphOverlay.classList.add('fading');
      setTimeout(() => {
        telegraphOverlay.classList.add('hidden');
        telegraphOverlay.classList.remove('fading');
        callback();
      }, 400);
    }, 1400);
  }

  /* ═══════════════════════════════════════════════════
     PROGRESS DOTS
     ═══════════════════════════════════════════════════ */

  function buildProgressDots() {
    const container = $('progressDots');
    container.innerHTML = '';
    for (let i = 0; i < TOTAL_EVENTS; i++) {
      const dot = document.createElement('span');
      dot.className = 'progress-dot';
      container.appendChild(dot);
    }
  }

  function updateProgressDots(currentIndex) {
    const dots = document.querySelectorAll('.progress-dot');
    dots.forEach((dot, i) => {
      dot.classList.toggle('completed', i < currentIndex);
      dot.classList.toggle('current', i === currentIndex);
    });
  }

  /* ═══════════════════════════════════════════════════
     LEARN MORE
     ═══════════════════════════════════════════════════ */

  learnMoreToggle.addEventListener('click', () => {
    const isOpen = learnMoreContent.classList.toggle('expanded');
    learnMoreToggle.innerHTML = isOpen ? 'Less &#9662;' : 'Learn more &#9656;';
  });

  function collapseLearnMore() {
    learnMoreContent.classList.remove('expanded');
    learnMoreToggle.innerHTML = 'Learn more &#9656;';
  }

  /* ═══════════════════════════════════════════════════
     HIGHLIGHT SYSTEM
     ═══════════════════════════════════════════════════ */

  function highlightTies(action) {
    const primaryLine = svgTies.querySelector(`.tie-line[data-tie="${action.primary.tie}"]`);
    if (primaryLine) primaryLine.classList.add('tie-highlight-primary');

    const primaryLabel = svgTies.querySelector(`.tie-hover-label[data-tie="${action.primary.tie}"]`);
    if (primaryLabel) primaryLabel.classList.add('visible');

    if (action.side) {
      const sideLine = svgTies.querySelector(`.tie-line[data-tie="${action.side.tie}"]`);
      if (sideLine) sideLine.classList.add(action.side.amount < 0 ? 'tie-highlight-cost' : 'tie-highlight-bonus');

      const sideLabel = svgTies.querySelector(`.tie-hover-label[data-tie="${action.side.tie}"]`);
      if (sideLabel) sideLabel.classList.add('visible');
    }
  }

  function clearHighlights() {
    svgTies.querySelectorAll('.tie-line').forEach(el => {
      el.classList.remove('tie-highlight-primary', 'tie-highlight-cost', 'tie-highlight-bonus');
    });
    svgTies.querySelectorAll('.tie-hover-label').forEach(el => {
      el.classList.remove('visible');
    });
  }

  /* ═══════════════════════════════════════════════════
     ACTION MARKERS (on network)
     ═══════════════════════════════════════════════════ */

  function svgToOverlayPercent(svgX, svgY) {
    // Convert SVG viewBox coords (0-480, 0-420) to percentage of the SVG element
    return { left: (svgX / 480) * 100, top: (svgY / 420) * 100 };
  }

  function clearActionMarkers() {
    actionOverlay.innerHTML = '';
    svgInd.querySelectorAll('.marker-connector').forEach(el => el.remove());
  }

  /* Fixed anchor points in SVG coords for connector lines */
  const MARKER_ANCHORS = [
    { x: 70, y: 50 },   /* slot-0: near top-left marker */
    { x: 410, y: 50 },  /* slot-1: near top-right marker */
    { x: 240, y: 380 }  /* slot-2: near bottom-center marker */
  ];

  function renderActionMarkers(actions) {
    clearActionMarkers();
    let expandedMarker = null;

    actions.forEach((action, idx) => {
      const mid = tieMidpoint(action.primary.tie);
      const anchor = MARKER_ANCHORS[idx];

      /* Draw connector line from slot anchor to tie midpoint */
      const connLine = svgEl('line', {
        x1: anchor.x, y1: anchor.y,
        x2: mid.x, y2: mid.y,
        class: 'marker-connector'
      });
      svgInd.appendChild(connLine);

      const tieDef = TIE_DEFS.find(t => t.id === action.primary.tie);
      const primaryName = tieDef ? tieDef.label : action.primary.tie;

      let effectsHtml = `<span style="color:var(--emerald)">${escapeHtml(primaryName)} +${action.primary.amount}</span>`;
      if (action.side) {
        const sideDef = TIE_DEFS.find(t => t.id === action.side.tie);
        const sideName = sideDef ? sideDef.label : action.side.tie;
        const sign = action.side.amount > 0 ? '+' : '';
        const color = action.side.amount < 0 ? 'var(--ruby)' : 'var(--emerald)';
        effectsHtml += ` &middot; <span style="color:${color}">${escapeHtml(sideName)} ${sign}${action.side.amount}</span>`;
      }

      const marker = document.createElement('div');
      marker.className = 'tie-action-marker slot-' + idx;
      marker.style.animationDelay = (idx * 100) + 'ms';
      marker.innerHTML = `
        <span class="marker-label">${escapeHtml(action.label)}</span>
        <span class="marker-desc">${escapeHtml(action.description)}</span>
        <span class="marker-effects">${effectsHtml}</span>
        <span class="marker-confirm">&#9654; Confirm</span>
      `;

      const line = svgTies.querySelector(`.tie-line[data-tie="${action.primary.tie}"]`);

      marker.addEventListener('click', (e) => {
        e.stopPropagation();
        if (marker.classList.contains('expanded')) {
          clearActionMarkers();
          clearHighlights();
          executeAction(action);
        } else {
          if (expandedMarker && expandedMarker !== marker) {
            expandedMarker.classList.remove('expanded');
            clearHighlights();
          }
          marker.classList.add('expanded');
          expandedMarker = marker;
          highlightTies(action);
        }
      });

      marker.addEventListener('mouseenter', () => {
        if (!marker.classList.contains('expanded')) {
          if (line) line.classList.add('tie-highlight-primary');
          const hoverLabel = svgTies.querySelector(`.tie-hover-label[data-tie="${action.primary.tie}"]`);
          if (hoverLabel) hoverLabel.classList.add('visible');
        }
      });

      marker.addEventListener('mouseleave', () => {
        if (!marker.classList.contains('expanded')) {
          if (line) line.classList.remove('tie-highlight-primary');
          const hoverLabel = svgTies.querySelector(`.tie-hover-label[data-tie="${action.primary.tie}"]`);
          if (hoverLabel) hoverLabel.classList.remove('visible');
        }
      });

      actionOverlay.appendChild(marker);
    });

    actionOverlay.addEventListener('click', () => {
      if (expandedMarker) {
        expandedMarker.classList.remove('expanded');
        expandedMarker = null;
        clearHighlights();
      }
    }, { once: true });
  }

  /* ═══════════════════════════════════════════════════
     GAME LOOP
     ═══════════════════════════════════════════════════ */

  function showRevealPrompt(ev) {
    const eventArea = $('eventCompact');
    // Show event title as tappable prompt
    evTitle.textContent = ev.title;
    evNarr.innerHTML = '';

    // Add tap hint
    const hint = document.createElement('div');
    hint.className = 'tap-hint';
    hint.textContent = 'tap to learn more';
    eventArea.appendChild(hint);

    // Make the event area clickable
    eventArea.classList.add('event-prompt');

    const revealHandler = () => {
      eventArea.classList.remove('event-prompt');
      hint.remove();
      eventArea.removeEventListener('click', revealHandler);

      // Reveal narration
      evNarr.innerHTML = formatText(ev.narration);

      // Learn more
      if (ev.learnMore) {
        learnMoreContent.innerHTML = formatText(ev.learnMore);
        learnMoreToggle.classList.remove('hidden');
        collapseLearnMore();
      }

      // Show action markers on the network (not cards at bottom)
      actionArea.classList.add('hidden');
      renderActionMarkers(ev.actions);
      gameActive = true;
    };

    eventArea.addEventListener('click', revealHandler);
  }

  function cleanupRevealPrompt() {
    const eventArea = $('eventCompact');
    eventArea.classList.remove('event-prompt');
    const oldHint = eventArea.querySelector('.tap-hint');
    if (oldHint) oldHint.remove();
    clearActionMarkers();
  }

  function showEvent() {
    if (!state || state.eventIndex >= TOTAL_EVENTS) return;
    const ev = EVENTS[state.eventIndex];

    updateProgressDots(state.eventIndex);
    gameDateEl.textContent = ev.date;

    // Clear stale content before telegraph
    actionCards.innerHTML = '';
    actionArea.classList.add('hidden');
    clearActionMarkers();
    evTitle.textContent = '';
    evNarr.innerHTML = '';
    learnMoreToggle.classList.add('hidden');
    collapseLearnMore();
    cleanupRevealPrompt();

    // Telegraph first
    showTelegraph(ev.telegraph, () => {
      // Apply strains FIRST — the visual main event
      svgInd.innerHTML = '';
      applyStrains(ev.strains, () => {
        // Check defeat after strain
        const broken = checkDefeat();
        if (broken) { endGame('defeat', broken); return; }

        // Show reveal prompt (title only, tappable)
        showRevealPrompt(ev);
      });
    });
  }

  function applyStrains(strains, callback) {
    strains.forEach((s, i) => {
      setTimeout(() => {
        state.ties[s.tie] = Math.max(0, state.ties[s.tie] - s.amount);
        animateStrain(s.tie, s.amount);
        updateSvg();
      }, i * 450);
    });
    setTimeout(callback, strains.length * 450 + 350);
  }

  /* (Action cards removed — actions now live on the network as markers) */

  function executeAction(action) {
    if (!gameActive || state.gameOver) return;
    gameActive = false;

    // Clear markers and highlights
    clearActionMarkers();
    clearHighlights();

    svgInd.innerHTML = '';

    // Apply primary effect
    state.ties[action.primary.tie] = Math.min(100, state.ties[action.primary.tie] + action.primary.amount);
    animateTend(action.primary.tie, action.primary.amount);

    // Apply side effect
    if (action.side) {
      setTimeout(() => {
        const amt = action.side.amount;
        state.ties[action.side.tie] = Math.max(0, Math.min(100, state.ties[action.side.tie] + amt));
        animateSideCost(action.side.tie, amt);
        updateSvg();
      }, 300);
    }

    // Passive decay on untouched ties
    const touched = new Set([action.primary.tie]);
    if (action.side) touched.add(action.side.tie);
    const currentEv = EVENTS[state.eventIndex];
    if (currentEv) currentEv.strains.forEach(s => touched.add(s.tie));

    TIE_DEFS.forEach(tie => {
      if (touched.has(tie.id)) return;
      const decay = DECAY_MIN + Math.floor(Math.random() * (DECAY_MAX - DECAY_MIN + 1));
      state.ties[tie.id] = Math.max(0, state.ties[tie.id] - decay);
    });

    updateSvg();

    // Check defeat
    const broken = checkDefeat();
    if (broken) {
      setTimeout(() => endGame('defeat', broken), 600);
      return;
    }

    // Advance
    state.eventIndex++;
    if (state.eventIndex >= TOTAL_EVENTS) {
      setTimeout(() => endGame('victory', null), 600);
      return;
    }

    setTimeout(() => {
      gameActive = true;
      showEvent();
    }, 1100);
  }

  /* ═══════════════════════════════════════════════════
     WIN / LOSS
     ═══════════════════════════════════════════════════ */

  function checkDefeat() {
    for (const tie of TIE_DEFS) {
      if (state.ties[tie.id] <= 0) return tie.id;
    }
    return null;
  }

  function endGame(outcome, brokenTie) {
    state.gameOver = true;
    state.outcome = outcome;
    gameActive = false;

    actionArea.classList.add('hidden');
    gameCont.classList.add('game-over');

    const total = Object.values(state.ties).reduce((a, b) => a + b, 0);

    if (outcome === 'victory') {
      statusMsg.textContent = 'Victory \u2014 The web holds.';
      statusMsg.className = 'status-message status-victory';
      evTitle.textContent = VICTORY.title || 'Victory';
      evNarr.innerHTML = formatText(VICTORY.narration || '');
      learnMoreToggle.classList.add('hidden');
      gameDateEl.textContent = 'December 1908';

      scorePanel.classList.remove('hidden');
      animateScore(total, scoreTotal);
      setTimeout(() => { scoreRank.textContent = getRank(total); }, 1200);

      if (VICTORY.reflection) {
        const items = VICTORY.reflection.map(p => `<li>${escapeHtml(p)}</li>`).join('');
        reflBox.innerHTML = `<div class="reflection-label">Reflection: The Price of Survival</div><p>Consider these questions:</p><ul>${items}</ul>`;
        reflBox.classList.remove('hidden');
      }
    } else {
      const defeat = DEFEATS[brokenTie] || {};
      const tieDef = TIE_DEFS.find(t => t.id === brokenTie);
      statusMsg.textContent = `Defeat \u2014 ${defeat.title || (tieDef ? tieDef.label + ' snapped' : 'A tie has broken.')}`;
      statusMsg.className = 'status-message status-defeat';
      evTitle.textContent = defeat.title || 'The Web Breaks';
      evNarr.innerHTML = formatText(defeat.narration || '');
      learnMoreToggle.classList.add('hidden');

      scorePanel.classList.remove('hidden');
      animateScore(total, scoreTotal);
      setTimeout(() => { scoreRank.textContent = 'Web Broken'; }, 1200);

      if (defeat.reflection) {
        const items = defeat.reflection.map(p => `<li>${escapeHtml(p)}</li>`).join('');
        reflBox.innerHTML = `<div class="reflection-label">Reflection: ${escapeHtml(defeat.title || 'What Broke')}</div><p>Consider these questions:</p><ul>${items}</ul>`;
        reflBox.classList.remove('hidden');
      }
    }

    restartBtn.classList.remove('hidden');
  }

  function animateScore(total, el) {
    let current = 0;
    const step = Math.max(1, Math.ceil(total / 40));
    const interval = setInterval(() => {
      current = Math.min(current + step, total);
      el.textContent = current;
      if (current >= total) clearInterval(interval);
    }, 30);
  }

  function getRank(score) {
    if (score >= 750) return 'Master Web-Spinner';
    if (score >= 600) return 'Skilled Diplomat';
    if (score >= 450) return 'Embattled Negotiator';
    return 'Barely Survived';
  }

  /* ═══════════════════════════════════════════════════
     RESTART
     ═══════════════════════════════════════════════════ */

  restartBtn.addEventListener('click', () => {
    gameCont.classList.add('hidden');
    gameCont.classList.remove('game-over');
    vigPanel.classList.remove('hidden');
    vigIdx = 0;
    showVig(0);
    statusMsg.textContent = '';
    statusMsg.className = 'status-message';
    scorePanel.classList.add('hidden');
    reflBox.innerHTML = '';
    reflBox.classList.add('hidden');
    restartBtn.classList.add('hidden');
    actionArea.classList.remove('hidden');
    actionArea.classList.remove('revealing');
    learnMoreToggle.classList.remove('hidden');
    collapseLearnMore();
    cleanupRevealPrompt();
    state = null;
    gameActive = false;
  });

  /* ═══════════════════════════════════════════════════
     INIT
     ═══════════════════════════════════════════════════ */

  showVig(0);

})();
</script>
</body>
</html>
